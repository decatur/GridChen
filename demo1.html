<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Column Types</title>

    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
            background-color: aliceblue;
        }

        label {
            display: inline-block;
            vertical-align: top;
            margin: 0 2em 0 0;
        }

        textarea {
            display: block;
            background-color: floralwhite;
            height: 200px;
            width: 100%;
        }
    </style>
</head>
<body>

<h1>Supported Column Data Types</h1>

<div>
    Demo is interactive both ways:
    <ul>
        <li>each change in schema or data will reset the grid, and</li>
        <li>each cell change will update the data.</li>
    </ul>
</div>

<div>
    Number of rows: <input value="1000"> <span style="margin-left:1em"></span>
</div>

<div id="template">
    <h2></h2>
    <label style="width: 40%;">
        JSON Schema
        <textarea class="schema"></textarea>
    </label>
    <label style="width: 40%;">
        JavaScript Data
        <textarea class="data"></textarea>
    </label>
    <label style="display: block;">
        Grid
        <grid-chen style="display: block; height: 200px;"></grid-chen>
    </label>
</div>


<script type="module">
    import "./modules/gridchen/GridChen.js"
    import {createInteractiveDemoGrid} from "./examples/demo.js"
    import {DatePartialTimeConverter, FullDateConverter, FullDate, DatePartialTime} from './modules/gridchen/converter.js'

    const input = document.querySelector('input');
    const span = document.querySelector('span');

    input.oninput = renderGrid;

    renderGrid();

    function renderGrid() {
        function range(count) {
            return Array.from({length: count}, (_, i) => i);
        }

        let rowCount = parseInt(input.value);
        if (isNaN(rowCount)) {
            span.textContent = 'Invalid row count ' + input.value;
            return;
        } else if (rowCount > 100000) {
            span.textContent = 'Take it easy...';
            return;
        }
        span.textContent = `Generated ${rowCount} Rows`;
        const schema = {
            title: 'demo',
            type: 'object',
            items: {
                type: 'object',
                items: [  // tuple schema
                    {title: 'FullDateString', width: 100, type: 'string', format: 'full-date'},
                    {title: 'FullDate', width: 100, type: 'FullDate'},
                    {title: 'DatePartialTimeString', width: 200, type: 'string', format: 'date-partial-time', frequency: 'T1M'},
                    {title: 'DatePartialTime', width: 200, type: 'DatePartialTime', frequency: 'T1M'},
                    {title: 'DateTimeString', width: 200, type: 'string', format: 'date-time', frequency: 'T1M'},
                    {title: 'DateTime', width: 200, type: 'Date', frequency: 'T1M'},
                    {title: 'Integer', width: 50, type: 'integer'},
                    {title: 'Digits1', width: 50, type: 'number', fractionDigits: 1},
                    {title: 'Digits2', width: 100, type: 'number', fractionDigits: 2},
                    {title: 'String', width: 100, type: 'string'},
                    {title: 'Enum', width: 50, type: 'string', enum: ['foo', 'bar']},
                    {title: 'Boolean', width: 100, type: 'boolean'},
                    {title: 'Uri', width: 200, type: 'string', format: 'uri'}
                ]
            }
        };

        // We simulate the data. Most likely this will come from the server via the Fetch API.
        let startDate = new Date('2019-01-01T00:00Z');
        const fullDateConverter = new FullDateConverter();
        const datePartialTimeConverter = new DatePartialTimeConverter();

        const simulate = {
            FullDateString: function(row) {
                const foo = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                const d = new FullDate(foo.getUTCFullYear(), foo.getUTCMonth(), foo.getUTCDate());
                return fullDateConverter.toString(d);
            },
            FullDate: function(row) {
                const foo = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                const d = new FullDate(foo.getUTCFullYear(), foo.getUTCMonth(), foo.getUTCDate());
                return d
            },
            DatePartialTimeString: function(row) {
                const foo = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                const d = new DatePartialTime(foo.getUTCFullYear(), foo.getUTCMonth(), foo.getUTCDate(), foo.getUTCMinutes(), foo.getUTCMinutes());
                return datePartialTimeConverter.toString(d)
            },
            DatePartialTime: function(row) {
                const foo = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                const d = new DatePartialTime(foo.getUTCFullYear(), foo.getUTCMonth(), foo.getUTCDate(), foo.getUTCMinutes(), foo.getUTCMinutes());
                return d
            },
            DateTimeString: function(row) {
                const d = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                return d.toISOString().replace(':00.000Z', 'Z');
            },
            DateTime: function(row) {
                const d = new Date(startDate.getTime() + row * 1000 * 60 * 15);
                return d;
            },
            Integer: (row) => row % 4?row:null,
            Digits1: (row) => row,
            Digits2: (row) => row,
            String: (row) => row % 2?`row ${row}`:undefined,
            Enum: (row) => ['foo', 'bar'][row],
            Boolean: (row) => row % 2 === 0,
            Uri: (row) => `[Link ${row}](http://foo.bar/${row})`
        };

        function simulateRows() {
            let rows = range(rowCount).map(i => schema.items.items.map((schema) => simulate[schema.title](i)));
            if (rowCount > 4) {
                delete rows[3];
                delete rows[4][1];
            }
            return rows
        }

        createInteractiveDemoGrid(document.getElementById('template'), schema, simulateRows());
    }


</script>
</body>
</html>
